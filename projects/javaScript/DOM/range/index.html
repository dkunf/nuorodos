<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Range</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container">
      <h2 id="data">--</h2>
      <div class="range-element">
        <div class="rail"></div>
        <div class="runner">
          <div class="needle"></div>
        </div>
      </div>

      <div class="ruler">
        <canvas class="canvas"></canvas>
      </div>
    </div>
    <!-- actually range slider is needed when 
      you want to see quickly results of using some very different values.
    Entering from keyboard takes more efforts and time,
    unless it's arrows, but arrows can change range insignifficantly
    while slider can be moved very significantly.
    Maybe 2d range is best for picking colors, right?
    because it's very visual and very quick to choose what you want.
      
    so to make sense using range slider:
    1: range changes are significant (otherwise arrow keys)
    2: you need to visualize effect of changing values quickly

    what if i use it applying a lot of css styles to some group 
    of elements and seeing effect of doing it immediately?????
for example margin,padding,height,width.

then flex with all flex options 
then grid with all grid options 

and i don't need to know which ones applied until i find suittable one :)
same with colors, shaddows, animation params etc.....

border-radii are tricky, gradients
-->
    <script>
      //this runner is not descrete,but continuos
      //goal is to make runner run to clicked coordinates
      const rangeEl = document.querySelector(".range-element");
      const rail = document.querySelector(".rail");
      const runner = document.querySelector(".runner");
      let needle = document.querySelector(".needle");
      let rulerContainer = document.querySelector(".ruler");
      const canvas = document.querySelector(".canvas");
      canvas.width = rangeEl.getBoundingClientRect().width;
      canvas.height = rangeEl.getBoundingClientRect().height + 100;
      const ctx = canvas.getContext("2d");

      // it moves now
      rangeEl.addEventListener("click", moveToClickedCoord);
      document.addEventListener("keydown", keyHandler);

      // logAllRects();
      let dataStep = drawRuler(ctx);

      function keyHandler(event) {
        let rangeRect = rangeEl.getBoundingClientRect();
        let leftEdgeOfRange = rangeRect.left;
        let runnerRect = runner.getBoundingClientRect();
        let runnerLocalCoordX = runnerRect.left - leftEdgeOfRange;
        if (event.key === "ArrowRight") {
          if (runnerRect.right < rangeRect.right) {
            runner.style.left = Math.round(runnerLocalCoordX + 1) + "px";
          }
        }
        if (event.key === "ArrowLeft") {
          if (runnerLocalCoordX >= 0.5)
            runner.style.left = Math.round(runnerLocalCoordX - 1) + "px";
        }
        showData(getDataFromView(needle.getBoundingClientRect().right + 1));
      }

      //now i want to add ruler or some reference to data
      //i am thinking of precision of 1px, can i do it like
      //on the slankmatis?
      function moveToClickedCoord(event) {
        //we switch to local coords by minus left edge of range
        let rangeRect = rangeEl.getBoundingClientRect();
        let runnerRect = runner.getBoundingClientRect();
        let clickedX = event.clientX;
        showData(getDataFromView(clickedX));
        let halfRunner = Math.round(runnerRect.width / 2);

        //left to the very edge
        if (clickedX < rangeRect.left + halfRunner) {
          runner.style.left = "0";
          return;
        }
        //right to the very edge
        if (clickedX > rangeRect.right - halfRunner) {
          runner.style.left = rangeRect.width - 2 * halfRunner + "px";

          return;
        }

        runner.style.left = clickedX - rangeRect.left - halfRunner + "px";
      }
      function getDataFromView(x) {
        //how many steps from beginning to this coord?
        let dx = x - canvas.getBoundingClientRect().left;

        return Math.round(dx / dataStep) - 1;
      }

      function showData(d) {
        let dataDisplay = document.getElementById("data");
        dataDisplay.textContent = d;
      }

      function drawRuler(ctx) {
        arr = Array(11).fill(1);
        //assuming only numbers for now
        let maxVal = Math.max(...arr.map((nr) => Math.abs(nr)));
        let normalized = arr.map((nr) => nr / maxVal);
        //now we need starting point and ending point:
        let startingPoint =
          needle.getBoundingClientRect().x - canvas.getBoundingClientRect().x;
        let endPoint = canvas.getBoundingClientRect().width - startingPoint;
        let range = endPoint - startingPoint;
        let step = range / (arr.length - 1);

        ctx.beginPath();
        ctx.strokeStyle = "#000";
        let i = 0;
        //otherwise last one may not be painted
        let adjustment = endPoint + 0.9 * step;
        for (let x = startingPoint; x <= adjustment; x += step) {
          ctx.moveTo(x, 100);
          ctx.lineTo(x, 150);
          ctx.strokeText(`${i}`, x - 2, 95);
          i++;
        }

        ctx.stroke();
        return step;
      }

      function logAllRects() {
        let rangeRect = rangeEl.getBoundingClientRect();
        let railRect = rail.getBoundingClientRect();
        let runnerRect = runner.getBoundingClientRect();
        let needleRect = needle.getBoundingClientRect();
        let rulerContainerRect = rulerContainer.getBoundingClientRect();
        let canvasRect = canvas.getBoundingClientRect();

        let rectangles = [
          rangeRect,
          railRect,
          runnerRect,
          needleRect,
          rulerContainerRect,
          canvasRect,
        ];

        console.log(`

        rangeRect, railRect, runnerRect, needleRect, rulerContainerRect, canvasRect

        leftSides:
        ${rectangles.map((r) => r.left)}
        rightSides:
        ${rectangles.map((r) => r.right)}
        widths:
        ${rectangles.map((r) => r.width)}
        `);
      }
    </script>
  </body>
</html>
